package ToBeSolved;

public class NoteFromGPT {



    public static void main(String[] args) {

        /*
        * 关于DP你所需要知道的一切
         *
         * 1.什么是DP？
         * "Dynamic programming meant to break problems into subproblems and solve them."
         * 这是DP的官方定义，很官方，但是并没有解决问题。实际上每一个问题的解决方案本质上都是分解问题，在这一点上看每一个问题都是DP。
         * 那么到底什么是DP？与其说什么是DP，不如说什么不是DP。DP是用来解决最优解问题的两种方案其一，也就是最优解问题中，贪心算法无法解决的就用DP。也就是说，PD就是非贪心解法。
         * 那么是什么是贪心算法？贪心算法就是每一步都只选择当前最优解。那么相对应的，DP就是每一步都选择全局最优解。全局最优解确实很难，因为每一次你都需要往前看，每一步都要参考前边的所有步骤，也因此DP一般复杂度都会高出贪心算法半个到一个数量级。
         *
         * 一句话来说就是，DP就是通过考察前边的每一步，得出现在这一步最优解的方法。也就是数学归纳法。而对应地，贪心算法就是只考察当前这一步，得出局部最优解。
         *
         * 2.DP如何优于贪心算法
         * 尽管给出了定义，但是DP仍然只是一个空泛的概念。下边以COIN CHANGE为例说明DP是如何工作的：
         *
         * （coin change问题）
         *
         * 最常见的当然是贪心算法，贪心算法会在每一步选当前最优。具体到这个问题就是，每一步都选最大的硬币，因为硬币越大，需要的硬币数量就越少。
         * 可是在面对用83, 186, 408,419这四枚硬币拼凑出6249时，贪心算法就失效了。
         * 贪心算法会先选419，一直选到无法再选为止，一共选了14枚419，还剩下383。再选2枚186，剩下11，到这里就无解了，贪心算法会直接给出-1.
         * 可是实际上6249=？？？+？？？，很明显贪心算法失败了。那么怎么用DP解决？
         *
         * 上文告诉我们，DP本质就是数学归纳法。也就是说，如果前一步已经是最优解了，那么前一步的最优解+这一步的最优解=全局最优解。
         * 比如用1，2和100拼出100，已知最优解就是1枚100了，那么拼出102的话此时的解就是在多一枚2和多两枚1之间选择，很明显多一枚2是最优解，那么最优解就是一枚100，加上这一步的最优解一枚2。
         * 那么COIN CHANGE我们的思路就是，首先得出第一个最优解，再将第一个最优解一直迭代到所需的值。如果所需的值无法被迭代出来，那么就证明最优解不存在。
         *
         * 那么第一个最优解从哪里来？显然在所需K时，最优解就是选一枚K，而不是两枚K/2。
         * 因此我们的思路就是，先将我们有的每一个硬币放下去一枚，也就是得到第一个最优解，之后再对于每一个数，尝试用最优解加一个硬币，也就是我们前文提到的这一步最优解，得到这个数的全局最优解。显然我们只能对每一个数进行迭代。对于M枚硬币拼出N的问题，复杂度就从O（log N）变成了O(N)
         *
         *
         * 3.DP如何解决贪心算法无法解决的排列组合问题
         * 尽管DP是从贪心算法出发的，但排列组合问题也可以用DP解决，而贪心算法并不能解决排列组合问题。
         * 例如 91 Decode Ways
         *
         * （Decode Ways）
         *
         * 首先我们从排列组合的角度出发，排列组合的基本原理是分类做加法，分步做乘法。
         * 因为是DP，所以我们只考虑每增加一位新数字时，增加的可能性。
         * 首先是每一位数都分开看待的这一种可能，很明显如果一开始就不考虑10-26组成新可能的情况，那么任何情况下这个字符串都只有一种可能，也就是逐位解读。
         * 那么在增加一位的时候发生了什么？如果新数字无法和前一位组成10-26，那么对于我们来说其实就相当于10-26的情况不存在，也就是可能性并没有增加。
         * 可是如果新的一位和前一位可以组成10-26了，那么情况就不一样了。
         * 这里不失一般性地假设字符串为XXX1，增加了一位3。
         * 首先XXX/1/3是可以想到的组合方式，可是这种组合方式已经被考虑过了，因此并不能增加可能性。
         * 其次对于XXX13来说，从此往后它就增加了一个分类，也就是说每一次在考虑可能时，XXX13都必须在第一步先分类，分成XXX1/3和XXX/13这两个大类，而又因为XXX1/3的可能性和XXX/13的可能性都和XXX相同，因此增加的可能性恰好就是XXX的可能性数。
         * 如果作图的话就是如下：
         *
         *           / XXX/13
         * XXX13  ---
         *           \ XXX/1/3
         *
         * 因此我们可以说，如果新数字无法组成10-26，那么可能性增加了0，否则就增加了前两位的所有可能。
         *
         * 4. DP关于排列组合的总结
         * 从上边可以看出，DP只关心增加的部分。DP解决排列组合时，如果增加的部分让它需要重新分类，那么就加上分类数，如果需要重新分步，那么就乘上分步数。
        * */


        /*
        * 动态规划（DP）详解：你需要知道的一切
        1. 什么是动态规划（DP）？
        “动态规划（Dynamic Programming）是将一个复杂问题拆分为子问题，并通过解决这些子问题来构建原问题的解。”

        这是动态规划的经典定义，然而它往往显得过于抽象，缺乏指导性。毕竟，大多数问题的解决过程本身就是“分解–解决–组合”。那么，动态规划到底是什么？与其定义“什么是DP”，不如理解“什么情况适合用DP”。

        动态规划常用于求解最优解问题，尤其是在贪心算法无法奏效的情境下。例如，一些最短路径、最小硬币数量、最大收益等问题中，若局部最优并不保证全局最优，便不能使用贪心算法，只能采用DP方法。

        简言之，DP 是用于解决无法通过贪心策略获得正确答案的最优子结构问题的一种算法框架。

        那么，什么是贪心算法？

        贪心算法指的是在每一步都做出当前看起来最优的选择，而不考虑未来的结果。它的效率高、实现简单，但只有在满足“贪心选择性质”时才有效。

        相比之下，动态规划则是基于“最优子结构”：当前问题的最优解依赖于其子问题的最优解。为了确保全局最优，DP 需要记录或回顾前面的计算结果，因此在时间与空间上通常比贪心算法复杂一个数量级。

        简而言之：

        贪心算法： 只看当前这一步（局部最优）

        动态规划： 每一步都参考前面（全局最优）

        2. 一个例子：动态规划如何优于贪心算法
        以经典的 Coin Change（零钱兑换） 问题为例：

        给定一组硬币面额和一个目标金额，求凑出该金额所需的最少硬币数。如果无法凑出，则返回 -1。

        错误的贪心方法：
        一个常见的错误策略是：每次选当前最大的硬币（期望用更少的硬币）。例如：

        硬币面额为 [83, 186, 408, 419]，目标为 6249。

        贪心策略会优先选用最多的 419：

        14 × 419 = 5866，剩下 383

        2 × 186 = 372，剩下 11

        剩下的 11 无法由可用硬币拼凑，算法失败，返回 -1

        然而，实际上存在一种组合方式可以凑出 6249。这说明贪心算法无法保证全局最优解。

        正确的 DP 方法：
        DP 的核心思想是：如果我们已经知道了金额 x 的最少硬币数，那么我们可以通过添加一枚硬币，得到金额 x+coin 的最少硬币数。

        因此我们可以设计一个数组 dp[i] 表示“凑出金额 i 所需的最少硬币数”，初始化为 dp[0] = 0，其他为无穷大。

        然后对每个硬币 coin 遍历所有金额 j，从 coin 到 target，尝试更新：

        dp[j] = min(dp[j], dp[j - coin] + 1)
        最终 dp[target] 就是所需的最少硬币数，若为无穷大则说明无法凑出。

        这种方式确保了每一步都考虑了前面的最优子问题，是典型的 DP 解法。其时间复杂度为 O(NM)，其中 N 是目标金额，M 是硬币种类。

        3. DP 如何解决贪心无法应对的排列组合问题？
        DP 不仅适用于最优化问题，也广泛应用于计数类问题，如排列组合，这是贪心算法完全无能为力的领域。

        例如，经典题目 Leetcode 91 - Decode Ways：

        给定一个只包含数字的字符串，求有多少种解码方式。'1' -> 'A', ..., '26' -> 'Z'

        分析：
        我们可以从组合数学的角度理解。排列组合的基本原则是：分类用加法，分步用乘法。

        解码方式也是如此：每次考虑是否可以将当前数字与前一个数字组成一个合法的两位数（10~26）：

        若可以，当前状态的解法数 = dp[i - 1]（只看最后一位） + dp[i - 2]（将最后两位合并）

        若不可以，仅等于 dp[i - 1]

        用图示表示（例如字符串为 XXX13）：

                  /--- XXX / 13 (合并解读)
        XXX13 ----
                  \--- XXX / 1 / 3（单独解读）
        因此：

        if s[i-1:i+1] in ['10' ~ '26']:
            dp[i] = dp[i - 1] + dp[i - 2]
        else:
            dp[i] = dp[i - 1]
        这正是动态规划的经典用法：只看每一位新增时带来的变化，并用前面已有解法累积当前解法。

        4. 小结：DP 解排列组合问题的原则
        在排列组合类问题中，DP 的核心思路是：

        只关注新增部分引入的变化

        若新增导致分类（如可两种方式解码），用加法

        若新增导致分步（如密码锁 N 位组合），用乘法

        通过逐步构建解的方式，DP 有效地避免了重复计算和暴力搜索，是处理这类问题的强有力工具。


        *
        * */




    }

}
